package com.github.ai.leetcodequiz.data.db.repository

import com.github.ai.leetcodequiz.data.db.dao.{ProblemEntityDao, ProblemHintEntityDao}
import com.github.ai.leetcodequiz.data.db.model.{
  ProblemEntity,
  ProblemHintEntity,
  ProblemId,
  ProblemHintId
}
import com.github.ai.leetcodequiz.entity.{Difficulty, Problem}
import com.github.ai.leetcodequiz.entity.exception.DatabaseError
import zio.*

class ProblemRepository(
  private val problemDao: ProblemEntityDao,
  private val hintDao: ProblemHintEntityDao
) {

  private def toEntities(problem: Problem): (ProblemEntity, List[ProblemHintEntity]) = {
    val problemEntity = ProblemEntity(
      id = problem.id,
      title = problem.title,
      content = problem.content,
      category = problem.category,
      url = problem.url,
      difficulty = problem.difficulty.toString,
      likes = problem.likes,
      dislikes = problem.dislikes
    )

    val hintEntities = problem.hints.zipWithIndex.map { case (hint, index) =>
      ProblemHintEntity(
        id = ProblemHintId(0), // Will be auto-generated by DB
        problemId = problem.id,
        hint = hint
      )
    }

    (problemEntity, hintEntities)
  }

  /** Converts ProblemEntity and questions to Problem domain entity
    */
  private def fromEntities(
    problemEntity: ProblemEntity,
    hints: List[ProblemHintEntity]
  ): Problem = {
    Problem(
      id = problemEntity.id,
      title = problemEntity.title,
      content = problemEntity.content,
      category = problemEntity.category,
      url = problemEntity.url,
      difficulty = Difficulty.from(problemEntity.difficulty).getOrElse(Difficulty.UNDEFINED),
      hints = hints.map(_.hint),
      likes = problemEntity.likes,
      dislikes = problemEntity.dislikes
    )
  }

  /** Get a problem by ID
    */
  def getById(id: ProblemId): IO[DatabaseError, Option[Problem]] = {
    for {
      problemOpt <- problemDao.getById(id)
      result <- problemOpt match {
        case Some(problemEntity) =>
          hintDao.getByProblemId(id).map { hints =>
            Some(fromEntities(problemEntity, hints))
          }
        case None =>
          ZIO.succeed(None)
      }
    } yield result
  }

  /** Get all problems
    */
  def getAll(): IO[DatabaseError, List[Problem]] = {
    for {
      problemEntities <- problemDao.getAll()
      problems <- ZIO.foreach(problemEntities) { problemEntity =>
        hintDao.getByProblemId(problemEntity.id).map { hints =>
          fromEntities(problemEntity, hints)
        }
      }
    } yield problems
  }

  /** Add a new problem
    */
  def add(problem: Problem): IO[DatabaseError, Problem] = {
    val (problemEntity, hintEntities) = toEntities(problem)

    for {
      addedProblem <- problemDao.add(problemEntity)
      addedHints <-
        if (hintEntities.nonEmpty) {
          hintDao.addBatch(hintEntities)
        } else {
          ZIO.succeed(List.empty)
        }
    } yield fromEntities(addedProblem, addedHints)
  }

  /** Update an existing problem
    */
  def update(problem: Problem): IO[DatabaseError, Problem] = {
    val (problemEntity, hintEntities) = toEntities(problem)

    for {
      updatedProblem <- problemDao.update(problemEntity)
      _ <- hintDao.deleteByProblemId(problem.id)
      addedHints <-
        if (hintEntities.nonEmpty) {
          hintDao.addBatch(hintEntities)
        } else {
          ZIO.succeed(List.empty)
        }
    } yield fromEntities(updatedProblem, addedHints)
  }

  /** Delete a problem by ID
    */
  def delete(id: ProblemId): IO[DatabaseError, Unit] = {
    for {
      _ <- hintDao.deleteByProblemId(id)
      _ <- problemDao.delete(id)
    } yield ()
  }

}
